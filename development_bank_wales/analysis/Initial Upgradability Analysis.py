# ---
# jupyter:
#   jupytext:
#     cell_metadata_filter: -all
#     comment_magics: true
#     text_representation:
#       extension: .py
#       format_name: percent
#       format_version: '1.3'
#       jupytext_version: 1.13.8
#   kernelspec:
#     display_name: development_bank_wales
#     language: python
#     name: development_bank_wales
# ---

# %% [markdown]
# # Initial Analysis of Recommendations and Upgrades for DBW Project
#
# Last updated: 19 July 2022
#
# This notebook demonstrates the initial analysis of recommendations and other EPC data for the DBW project. The actual upgradability model is introduced in another notebook.
#
# **Note for reviewer**:
# This notebook does not have to be reviewed in much detail. Please just check whether everything runs smoothly.

# %%
# %load_ext autoreload
# %autoreload 2

import asf_core_data
from asf_core_data.pipeline.preprocessing import (
    preprocess_epc_data,
    feature_engineering,
)
from asf_core_data.getters.epc import epc_data
from asf_core_data.getters.supplementary_data.deprivation import imd_data
from asf_core_data.utils.visualisation import easy_plotting, kepler
from asf_core_data.utils.geospatial import data_agglomeration

from development_bank_wales import PROJECT_DIR, Path
from development_bank_wales.pipeline.feature_preparation import (
    recommendations,
    data_aggregation,
)
from development_bank_wales.pipeline.feature_preparation.legacy import upgrades

import re
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

from keplergl import KeplerGl

from ipywidgets import interact, fixed

# %% [markdown]
# ## Loading the data
#
# The first time, this takes about 5min. Time for a quick break!

# %%
output_path = PROJECT_DIR / "outputs/data/wales_epc_with_recs.csv"
fig_output_path = PROJECT_DIR / "outputs/figures/autogenerated/"

if not Path(output_path).is_file():

    print("Loading and preparing the data...")

    wales_df = recommendations.load_epc_certs_and_recs(
        data_path="S3", subset="Wales", n_samples=None, remove_duplicates=False
    )

    wales_df.to_csv(output_path, index=False)

    print("Done!")

else:

    print("Loading the data...")
    wales_df = pd.read_csv(output_path)
    print("Done!")

# %% [markdown]
# ## Recommendations
#
# There's 41 different default recommendations in the Wales EPC Register. 85% of all records have at least one recommendation.
#
# The auto-generated plots show the relation of difference recommendations to property characteristics, e.g. property type or construction age band. For example, only houses and bungalows ever receive a recommendation for solar water heating. The charts can be polished if ever needed.

# %%
unique_recs = [col for col in wales_df.columns if col.startswith("Rec:")]

print(
    "Number of different recommendations:",
    len(unique_recs),
)
round(wales_df["HAS_ANY_RECOM"].value_counts(dropna=False, normalize=True), 2)

# %%
recs = unique_recs + ["HAS_ANY_RECOM"]


@interact(rec=recs)
def plot_recommendations(rec):
    easy_plotting.plot_subcats_by_other_subcats(
        wales_df,
        "PROPERTY_TYPE",
        rec,
        plotting_colors="copper",
        x_tick_rotation=45,
        fig_save_path=fig_output_path,
    )
    easy_plotting.plot_subcats_by_other_subcats(
        wales_df,
        "BUILT_FORM",
        rec,
        plotting_colors="copper",
        x_tick_rotation=45,
        fig_save_path=fig_output_path,
    )
    easy_plotting.plot_subcats_by_other_subcats(
        wales_df,
        "CONSTRUCTION_AGE_BAND",
        rec,
        plotting_colors="copper",
        x_tick_rotation=45,
        fig_save_path=fig_output_path,
    )
    easy_plotting.plot_subcats_by_other_subcats(
        wales_df,
        "CURRENT_ENERGY_RATING",
        rec,
        plotting_colors="copper",
        x_tick_rotation=45,
        fig_save_path=fig_output_path,
    )
    easy_plotting.plot_subcats_by_other_subcats(
        wales_df,
        "LOCAL_AUTHORITY_LABEL",
        rec,
        plotting_colors="copper",
        x_tick_rotation=45,
        fig_save_path=fig_output_path,
    )
    easy_plotting.plot_subcats_by_other_subcats(
        wales_df,
        "TENURE",
        rec,
        plotting_colors="copper",
        x_tick_rotation=45,
        fig_save_path=fig_output_path,
    )


# %% [markdown]
# ### Recommendations over Time
#
# Looking at properties with multiple records over time, we can estimate which upgrades are often carried out and which recommendations are implemented, although this is not a water-proof solution, of course.

# %%
wales_df = wales_df.loc[wales_df["TENURE"] == "owner-occupied"]


latest_wales = epc_data.filter_by_year(
    wales_df.loc[wales_df["N_SAME_UPRN_ENTRIES"] > 1],
    None,
    selection="latest entry",
)
first_wales = epc_data.filter_by_year(
    wales_df.loc[wales_df["N_SAME_UPRN_ENTRIES"] > 1],
    None,
    selection="first entry",
)

# %%
for rec in unique_recs:

    first_wales_with_rec = recommendations.check_for_implemented_rec(
        rec, first_wales, latest_wales, identifier="UPRN", keep="first"
    )
    print(round(first_wales_with_rec[rec].value_counts(normalize=True), 2))
    print()


# %%
@interact(rec=recs, first_wales=fixed(first_wales), latest_wales=fixed(latest_wales))
def plot_recommendations(rec, first_wales, latest_wales):

    first_wales_with_rec = recommendations.check_for_implemented_rec(
        rec, first_wales, latest_wales, keep="first", identifier="UPRN"
    )

    print(rec)
    print(
        "IMPLEMENTED_" + rec,
    )

    # Only look at samples with this recommendation
    first_wales_with_rec = first_wales_with_rec.loc[first_wales_with_rec[rec]]

    easy_plotting.plot_subcats_by_other_subcats(
        first_wales_with_rec,
        "PROPERTY_TYPE",
        "IMPLEMENTED_" + rec,
        plotting_colors="copper",
        x_tick_rotation=45,
        fig_save_path=fig_output_path,
    )
    easy_plotting.plot_subcats_by_other_subcats(
        first_wales_with_rec,
        "BUILT_FORM",
        "IMPLEMENTED_" + rec,
        plotting_colors="copper",
        x_tick_rotation=45,
        fig_save_path=fig_output_path,
    )
    easy_plotting.plot_subcats_by_other_subcats(
        first_wales_with_rec,
        "CONSTRUCTION_AGE_BAND",
        "IMPLEMENTED_" + rec,
        plotting_colors="copper",
        x_tick_rotation=45,
        fig_save_path=fig_output_path,
    )
    easy_plotting.plot_subcats_by_other_subcats(
        first_wales_with_rec,
        "CURRENT_ENERGY_RATING",
        "IMPLEMENTED_" + rec,
        plotting_colors="copper",
        x_tick_rotation=45,
        fig_save_path=fig_output_path,
    )
    easy_plotting.plot_subcats_by_other_subcats(
        first_wales_with_rec,
        "LOCAL_AUTHORITY_LABEL",
        "IMPLEMENTED_" + rec,
        plotting_colors="copper",
        x_tick_rotation=45,
        fig_save_path=fig_output_path,
    )


# %% [markdown]
# ## Upgradability (simple version)
#
# We measure upgradability based on whether a property has had an improvement in a specific category or whether there has been a recommendation.

# %%
first_wales_w_upgrades = upgrades.get_upgrade_features(
    first_wales, latest_wales, keep="first"
)

latest_wales_w_upgrades = upgrades.get_upgrade_features(
    first_wales, latest_wales, keep="latest", verbose=False
)

# %%
cats = ["ROOF", "WINDOWS", "WALLS", "FLOOR", "LIGHTING", "HOT_WATER", "MAINHEAT"]


upgrade_df = pd.DataFrame(
    index=cats,
    columns=[
        "Recommendations (%)",
        "Upgrades (%)",
        "Recommendations or Upgrades (%)",
        "Recommendations and Upgrades (%)",
        "Recommendations and Upgrades (% of all with recs)",
        "Upgradability (mean)",
    ],
)
upgrade_df = upgrade_df.astype(float)


for cat in cats:

    total_props = first_wales_w_upgrades.shape[0]
    total_props_with_rec = first_wales_w_upgrades.loc[
        (first_wales_w_upgrades["{}_RECOMMENDATION".format(cat)])
    ].shape[0]
    total_props_with_upgr = first_wales_w_upgrades.loc[
        (first_wales_w_upgrades["{}_EFF_DIFF".format(cat)] > 0)
    ].shape[0]

    props_w_upgr_and_rec = first_wales_w_upgrades.loc[
        (
            (first_wales_w_upgrades["{}_EFF_DIFF".format(cat)] > 0)
            & (first_wales_w_upgrades["{}_RECOMMENDATION".format(cat)])
        )
    ].shape[0]

    props_w_upgr_or_rec = first_wales_w_upgrades.loc[
        (
            (first_wales_w_upgrades["{}_EFF_DIFF".format(cat)] > 0)
            | (first_wales_w_upgrades["{}_RECOMMENDATION".format(cat)])
        )
    ].shape[0]

    first_wales_w_upgrades["{}_UPGRADABILITY".format(cat)] = (
        first_wales_w_upgrades["{}_EFF_DIFF".format(cat)] > 0.0
    ) | (first_wales_w_upgrades["{}_RECOMMENDATION".format(cat)])

    upgrade_dict = {
        "Recommendations (%)": total_props_with_rec / total_props * 100,
        "Upgrades (%)": total_props_with_upgr / total_props * 100,
        "Recommendations or Upgrades (%)": props_w_upgr_or_rec / total_props * 100,
        "Recommendations and Upgrades (%)": props_w_upgr_and_rec / total_props * 100,
        "Recommendations and Upgrades (% of all with recs)": props_w_upgr_and_rec
        / total_props_with_rec
        * 100,
        "Upgradability (mean)": first_wales_w_upgrades[
            "{}_UPGRADABILITY".format(cat)
        ].mean()
        * 100,
    }

    upgrade_df.loc[cat] = pd.Series(upgrade_dict)


upgrade_df = round(upgrade_df)
upgrade_df.head(10)


# %%
@interact(
    cat=cats,
    feature=[
        "BUILT_FORM",
        "PROPERTY_TYPE",
        "CONSTRUCTION_AGE_BAND",
        "TRANSACTION_TYPE",
    ],
)
def plotting(cat, feature):
    easy_plotting.plot_subcats_by_other_subcats(
        latest_wales_w_upgrades,
        "UPGRADED_" + cat + "_DESCRIPTION",
        feature,
        plotting_colors="inferno",
        x_tick_rotation=45,
        legend_loc="outside",
        fig_save_path=fig_output_path,
    )


# %% [markdown]
# ### Upgrade Network
#
# Which upgrades often happen at the same time?

# %%
upgrades.uprade_connections(first_wales_w_upgrades)

# %% [markdown]
# ## Transitions
#
# Currently, we don't work with transitions but we could analyse them if ever required.

# %%
pd.set_option("display.max_rows", 5000)


@interact(cat=cats)
def get_transitions(cat):
    print(
        round(
            latest_wales_w_upgrades["CHANGE_{}_DESCRIPTION".format(cat)].value_counts(
                normalize=True
            ),
            5,
        )
        * 100
    )


# %% [markdown]
# ## Geographical and IMD Data
#
# Add geographical data and information about deprivation.

# %%
first_wales_suppl = data_aggregation.get_supplementary_data(
    first_wales_w_upgrades, data_path="S3"
)
first_wales_suppl.head()

# %% [markdown]
# ## Kepler Maps
#
# Kepler maps showing upgradability, efficiency and rating difference over time. Not used in that form in the final analysis.
#
# ### Upgradability

# %%
kepler_df = data_aggregation.get_aggregated_upgrade_data(first_wales_suppl, "hex_id")

config = kepler.get_config("upgrades.txt", data_path=PROJECT_DIR)
upgrade_map = KeplerGl(height=500, config=config)

upgrade_map.add_data(
    data=kepler_df[["UPGRADABILITY_TOTAL_MEAN", "hex_id"]], name="Total Upgradability"
)

upgrade_map.add_data(
    data=kepler_df[["UPGRADABILITY_ROOF_MEAN", "hex_id"]], name="Roof Upgradability"
)

upgrade_map.add_data(
    data=kepler_df[["UPGRADABILITY_WINDOWS_MEAN", "hex_id"]],
    name="Windows Upgradability",
)

upgrade_map.add_data(
    data=kepler_df[["UPGRADABILITY_MAINHEAT_MEAN", "hex_id"]],
    name="Heating Upgradability",
)

upgrade_map.add_data(
    data=kepler_df[["UPGRADABILITY_LIGHTING_MEAN", "hex_id"]],
    name="Lighting Upgradability",
)

upgrade_map.add_data(
    data=kepler_df[["IMD Decile Hex", "hex_id"]], name="IMD Decile for Hex"
)


upgrade_map

# %%
kepler.save_config(upgrade_map, "upgrades.txt", data_path=PROJECT_DIR)
kepler.save_map(upgrade_map, "Upgrades.html", data_path=PROJECT_DIR)

# %% [markdown]
# ### Upgradability by Local Authority

# %%
kepler_df = data_aggregation.get_aggregated_upgrade_data(
    first_wales_suppl, "LOCAL_AUTHORITY_LABEL"
)

config = kepler.get_config("LA_upgrades.txt", data_path=PROJECT_DIR)
upgrade_map = KeplerGl(height=500, config=config)

upgrade_map.add_data(
    data=kepler_df[
        ["UPGRADABILITY_TOTAL_MEAN", "MOST_FREQUENT_LOCAL_AUTHORITY_LABEL", "hex_id"]
    ],
    name="Total Upgradability",
)

upgrade_map.add_data(
    data=kepler_df[
        ["UPGRADABILITY_ROOF_MEAN", "MOST_FREQUENT_LOCAL_AUTHORITY_LABEL", "hex_id"]
    ],
    name="Roof Upgradability",
)

upgrade_map.add_data(
    data=kepler_df[
        ["UPGRADABILITY_WINDOWS_MEAN", "MOST_FREQUENT_LOCAL_AUTHORITY_LABEL", "hex_id"]
    ],
    name="Windows Upgradability",
)

upgrade_map.add_data(
    data=kepler_df[
        ["UPGRADABILITY_MAINHEAT_MEAN", "MOST_FREQUENT_LOCAL_AUTHORITY_LABEL", "hex_id"]
    ],
    name="Heating Upgradability",
)

upgrade_map.add_data(
    data=kepler_df[
        ["UPGRADABILITY_LIGHTING_MEAN", "MOST_FREQUENT_LOCAL_AUTHORITY_LABEL", "hex_id"]
    ],
    name="Lighting Upgradability",
)

upgrade_map.add_data(
    data=kepler_df[["IMD Decile Hex", "MOST_FREQUENT_LOCAL_AUTHORITY_LABEL", "hex_id"]],
    name="IMD Decile for Hex",
)

upgrade_map

# %%
kepler.save_config(upgrade_map, "LA_upgrades.txt", data_path=PROJECT_DIR)
kepler.save_map(upgrade_map, "LA_Upgrades.html", data_path=PROJECT_DIR)

# %% [markdown]
# ## Energy Efficiency

# %%
kepler_df = data_aggregation.get_aggregated_upgrade_data(first_wales_suppl, "hex_id")

config = kepler.get_config("efficiencies.txt", data_path=PROJECT_DIR)
upgrade_map = KeplerGl(height=500, config=config)

upgrade_map.add_data(
    data=kepler_df[["TOTAL_ENERGY_EFF_NUM_MEAN", "hex_id"]],
    name="Total Energy Efficiency",
)

upgrade_map.add_data(
    data=kepler_df[["ROOF_ENERGY_EFF_NUM_MEAN", "hex_id"]],
    name="Roof Energy Efficiency",
)

upgrade_map.add_data(
    data=kepler_df[["WINDOWS_ENERGY_EFF_NUM_MEAN", "hex_id"]],
    name="Windows Energy Efficiency",
)

upgrade_map.add_data(
    data=kepler_df[["MAINHEAT_ENERGY_EFF_NUM_MEAN", "hex_id"]],
    name="Heating Energy Efficiency",
)

upgrade_map.add_data(
    data=kepler_df[["LIGHTING_ENERGY_EFF_NUM_MEAN", "hex_id"]],
    name="Lighting Energy Efficiency",
)

upgrade_map.add_data(
    data=kepler_df[["IMD Decile Hex", "hex_id"]], name="IMD Decile for Hex"
)

upgrade_map

# %%
kepler.save_config(upgrade_map, "efficiencies.txt", data_path=PROJECT_DIR)
kepler.save_map(upgrade_map, "Efficiencies.html", data_path=PROJECT_DIR)

# %% [markdown]
# ## Rating Diff

# %%
kepler_df = data_aggregation.get_aggregated_upgrade_data(first_wales_suppl, "hex_id")

config = kepler.get_config("diffs.txt", data_path=PROJECT_DIR)
upgrade_map = KeplerGl(height=500, config=config)

upgrade_map.add_data(
    data=kepler_df[["TOTAL_EFF_DIFF_MEAN", "hex_id"]], name="Total Upgrades"
)

upgrade_map.add_data(
    data=kepler_df[["ROOF_EFF_DIFF_MEAN", "hex_id"]], name="Roof Upgrades"
)

upgrade_map.add_data(
    data=kepler_df[["WINDOWS_EFF_DIFF_MEAN", "hex_id"]], name="Windows Upgrades"
)


upgrade_map.add_data(
    data=kepler_df[["MAINHEAT_EFF_DIFF_MEAN", "hex_id"]], name="Heating Upgrades"
)

upgrade_map.add_data(
    data=kepler_df[["LIGHTING_EFF_DIFF_MEAN", "hex_id"]], name="Lighting Upgrades"
)

upgrade_map.add_data(
    data=kepler_df[["IMD Decile Hex", "hex_id"]], name="IMD Decile for Hex"
)
upgrade_map

# %%
kepler.save_config(upgrade_map, "diffs.txt", data_path=PROJECT_DIR)
kepler.save_map(upgrade_map, "Differences.html", data_path=PROJECT_DIR)

# %%
