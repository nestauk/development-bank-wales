# ---
# jupyter:
#   jupytext:
#     cell_metadata_filter: -all
#     comment_magics: true
#     text_representation:
#       extension: .py
#       format_name: percent
#       format_version: '1.3'
#       jupytext_version: 1.13.8
#   kernelspec:
#     display_name: development_bank_wales
#     language: python
#     name: development_bank_wales
# ---

# %% [markdown]
# # Initial Analysis of Recommendations and Upgrades for DBW Project
#
# Last updated: 20 July 2022 by Julia Suter
#
# ### Structure of Notebook<a id='top'></a>
#
# [**Welcome to the Playground**](#notebook)
#
# [**Loading the EPC data**](#loading)
#
# [**Recommendations**](#recs)
# - [What can the data tell us](#recs_basics)
# - [Recommendations over time](#recs_over_time)
#
# [**Upgrades and Upgradability**](#upgradability)
# - [What can the data tell us](#upgradability_basics)
# - [Upgrade network](#upgrade_network)
# - [Transitions](#transitions)
#
# [**Kepler Maps**](#kepler)
# - [Geographical and IMD data](#supp_data)
# - [Upgradability map](#upgradability_map)
# - [Upgradability map by Local Authority](#upgradability_map_LA)
# - [Energy efficiency map](#en_eff)
# - [Rating difference map](#rating_diff)
#
#
# ## Welcome to the Playground
#
# This notebook demonstrates the initial analysis of recommendations and other EPC data for the DBW project. The actual upgradability model is introduced in another notebook. Consider this a playground.
#
# **Note for reviewer**:
# This notebook does not have to be reviewed in much detail. Please just check whether everything runs smoothly.
#

# %%
# %load_ext autoreload
# %autoreload 2

import asf_core_data
from asf_core_data.pipeline.preprocessing import (
    preprocess_epc_data,
    feature_engineering,
)
from asf_core_data.getters.epc import epc_data
from asf_core_data.getters.supplementary_data.deprivation import imd_data
from asf_core_data.utils.visualisation import easy_plotting, kepler
from asf_core_data.utils.geospatial import data_agglomeration

from development_bank_wales import PROJECT_DIR, Path
from development_bank_wales.pipeline.feature_preparation import (
    recommendations,
    data_aggregation,
)
from development_bank_wales.pipeline.feature_preparation.legacy import upgrades

import re
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

from keplergl import KeplerGl

from ipywidgets import interact, fixed

# %% [markdown]
# ## Loading the data<a id='loading'></a>
# [[back to top]](#top)
#
# When executed the very first time, the EPC data is loaded from S3 and saved in `/outputs/data/`. This takes about 5min. After that, the data will be loaded from the local directory (<30 secs).

# %%
output_path = PROJECT_DIR / "outputs/data/wales_epc_with_recs.csv"
fig_output_path = PROJECT_DIR / "outputs/figures/autogenerated/"

if not Path(output_path).is_file():

    print("Loading and preparing the data...")

    wales_df = recommendations.load_epc_certs_and_recs(
        data_path="S3", subset="Wales", n_samples=None, remove_duplicates=False
    )

    wales_df.to_csv(output_path, index=False)

    print("Done!")

else:

    print("Loading the data...")
    wales_df = pd.read_csv(output_path)
    print("Done!")

# %% [markdown]
# ## Recommendations<a id='recs'></a>
# [[back to top]](#top)
#
# ###Â What can the data tell us<a id='recs_basics'></a>
#
# There are 41 different default recommendations in the Wales EPC Register. 85% of all records have at least one recommendation.
#
# The auto-generated plots show the relation of different recommendations to various property characteristics, e.g. property type or construction age band. For example, only houses and bungalows ever receive a recommendation for solar water heating. The charts can be polished if ever needed.

# %%
unique_recs = [col for col in wales_df.columns if col.startswith("Rec:")]

print(
    "Number of different recommendations:",
    len(unique_recs),
)
round(wales_df["HAS_ANY_RECOM"].value_counts(dropna=False, normalize=True), 2)

# %%
recs = unique_recs + ["HAS_ANY_RECOM"]


@interact(rec=recs)
def plot_recommendations(rec):
    easy_plotting.plot_subcats_by_other_subcats(
        wales_df,
        "PROPERTY_TYPE",
        rec,
        plotting_colors="copper",
        x_tick_rotation=45,
        figsize=(7, 5),
        fig_save_path=fig_output_path,
    )
    easy_plotting.plot_subcats_by_other_subcats(
        wales_df,
        "BUILT_FORM",
        rec,
        plotting_colors="copper",
        x_tick_rotation=45,
        figsize=(7, 5),
        fig_save_path=fig_output_path,
    )
    easy_plotting.plot_subcats_by_other_subcats(
        wales_df,
        "CONSTRUCTION_AGE_BAND",
        rec,
        plotting_colors="copper",
        x_tick_rotation=45,
        figsize=(7, 5),
        fig_save_path=fig_output_path,
    )
    easy_plotting.plot_subcats_by_other_subcats(
        wales_df,
        "CURRENT_ENERGY_RATING",
        rec,
        plotting_colors="copper",
        x_tick_rotation=45,
        figsize=(7, 5),
        fig_save_path=fig_output_path,
    )
    easy_plotting.plot_subcats_by_other_subcats(
        wales_df,
        "LOCAL_AUTHORITY_LABEL",
        rec,
        plotting_colors="copper",
        x_tick_rotation=45,
        figsize=(7, 5),
        fig_save_path=fig_output_path,
    )
    easy_plotting.plot_subcats_by_other_subcats(
        wales_df,
        "TENURE",
        rec,
        plotting_colors="copper",
        x_tick_rotation=45,
        figsize=(7, 5),
        fig_save_path=fig_output_path,
    )


# %% [markdown]
# ### Recommendations over Time<a id='recs_over_time'></a>
# [[back to top]](#top)
#
# Looking at properties with multiple records over time, we can estimate which upgrades are often carried out and which recommendations are implemented. Note that this only an approximation as we do not hold information for all properties, and only one record for many.

# %%
wales_df = wales_df.loc[wales_df["TENURE"] == "owner-occupied"]


latest_wales = epc_data.filter_by_year(
    wales_df.loc[wales_df["N_SAME_UPRN_ENTRIES"] > 1],
    None,
    selection="latest entry",
)
first_wales = epc_data.filter_by_year(
    wales_df.loc[wales_df["N_SAME_UPRN_ENTRIES"] > 1],
    None,
    selection="first entry",
)

# %%
for rec in unique_recs:

    first_wales_with_rec = recommendations.check_for_implemented_rec(
        rec, first_wales, latest_wales, identifier="UPRN", keep="first"
    )
    print(round(first_wales_with_rec[rec].value_counts(normalize=True), 2))
    print()


# %%
@interact(rec=recs, first_wales=fixed(first_wales), latest_wales=fixed(latest_wales))
def plot_recommendations(rec, first_wales, latest_wales):

    first_wales_with_rec = recommendations.check_for_implemented_rec(
        rec, first_wales, latest_wales, keep="first", identifier="UPRN"
    )

    print(rec)
    print(
        "IMPLEMENTED_" + rec,
    )

    # Only look at samples with this recommendation
    first_wales_with_rec = first_wales_with_rec.loc[first_wales_with_rec[rec]]

    easy_plotting.plot_subcats_by_other_subcats(
        first_wales_with_rec,
        "PROPERTY_TYPE",
        "IMPLEMENTED_" + rec,
        plotting_colors="copper",
        x_tick_rotation=45,
        figsize=(7, 5),
        fig_save_path=fig_output_path,
    )
    easy_plotting.plot_subcats_by_other_subcats(
        first_wales_with_rec,
        "BUILT_FORM",
        "IMPLEMENTED_" + rec,
        plotting_colors="copper",
        x_tick_rotation=45,
        figsize=(7, 5),
        fig_save_path=fig_output_path,
    )
    easy_plotting.plot_subcats_by_other_subcats(
        first_wales_with_rec,
        "CONSTRUCTION_AGE_BAND",
        "IMPLEMENTED_" + rec,
        plotting_colors="copper",
        x_tick_rotation=45,
        figsize=(7, 5),
        fig_save_path=fig_output_path,
    )
    easy_plotting.plot_subcats_by_other_subcats(
        first_wales_with_rec,
        "CURRENT_ENERGY_RATING",
        "IMPLEMENTED_" + rec,
        plotting_colors="copper",
        x_tick_rotation=45,
        figsize=(7, 5),
        fig_save_path=fig_output_path,
    )
    easy_plotting.plot_subcats_by_other_subcats(
        first_wales_with_rec,
        "LOCAL_AUTHORITY_LABEL",
        "IMPLEMENTED_" + rec,
        plotting_colors="copper",
        x_tick_rotation=45,
        figsize=(7, 5),
        fig_save_path=fig_output_path,
    )


# %% [markdown]
# ## Upgrades and Upgradability<a id='upgradability'></a>
# [[back to top]](#top)
#
#
# ### What can the data tell us <a id='upgradability_basics'></a>
# We measure upgradability based on whether a property has had an improvement in a specific category or whether there has been a recommendation.
#
# The most upgrades happen in the category 'lighting' since it's the easiest one. There are hardly any (recorded) upgrades done to the floor of a property, as it is a real hassle.
#
# Mainheat, hot water and lighting are most frequently recommended to be upgraded. When only looking at properties with specific recommendation, then lighting, roof and windows are more frequently upgraded.

# %%
first_wales_w_upgrades = upgrades.get_upgrade_features(
    first_wales, latest_wales, keep="first"
)

latest_wales_w_upgrades = upgrades.get_upgrade_features(
    first_wales, latest_wales, keep="latest", verbose=False
)

# %%
cats = ["ROOF", "WINDOWS", "WALLS", "FLOOR", "LIGHTING", "HOT_WATER", "MAINHEAT"]


upgrade_df = pd.DataFrame(
    index=cats,
    columns=[
        "Recommendations (%)",
        "Upgrades (%)",
        "Recommendations or Upgrades (%)",
        "Recommendations and Upgrades (%)",
        "Recommendations and Upgrades (% of all with recs)",
        "Upgradability (mean)",
    ],
)
upgrade_df = upgrade_df.astype(float)


for cat in cats:

    total_props = first_wales_w_upgrades.shape[0]
    total_props_with_rec = first_wales_w_upgrades.loc[
        (first_wales_w_upgrades["{}_RECOMMENDATION".format(cat)])
    ].shape[0]
    total_props_with_upgr = first_wales_w_upgrades.loc[
        (first_wales_w_upgrades["{}_EFF_DIFF".format(cat)] > 0)
    ].shape[0]

    props_w_upgr_and_rec = first_wales_w_upgrades.loc[
        (
            (first_wales_w_upgrades["{}_EFF_DIFF".format(cat)] > 0)
            & (first_wales_w_upgrades["{}_RECOMMENDATION".format(cat)])
        )
    ].shape[0]

    props_w_upgr_or_rec = first_wales_w_upgrades.loc[
        (
            (first_wales_w_upgrades["{}_EFF_DIFF".format(cat)] > 0)
            | (first_wales_w_upgrades["{}_RECOMMENDATION".format(cat)])
        )
    ].shape[0]

    first_wales_w_upgrades["{}_UPGRADABILITY".format(cat)] = (
        first_wales_w_upgrades["{}_EFF_DIFF".format(cat)] > 0.0
    ) | (first_wales_w_upgrades["{}_RECOMMENDATION".format(cat)])

    upgrade_dict = {
        "Recommendations (%)": total_props_with_rec / total_props * 100,
        "Upgrades (%)": total_props_with_upgr / total_props * 100,
        "Recommendations or Upgrades (%)": props_w_upgr_or_rec / total_props * 100,
        "Recommendations and Upgrades (%)": props_w_upgr_and_rec / total_props * 100,
        "Recommendations and Upgrades (% of all with recs)": props_w_upgr_and_rec
        / total_props_with_rec
        * 100,
        "Upgradability (mean)": first_wales_w_upgrades[
            "{}_UPGRADABILITY".format(cat)
        ].mean()
        * 100,
    }

    upgrade_df.loc[cat] = pd.Series(upgrade_dict)


upgrade_df = round(upgrade_df)
upgrade_df.head(10)


# %%
@interact(
    cat=cats,
    feature=[
        "PROPERTY_TYPE",
        "BUILT_FORM",
        "CONSTRUCTION_AGE_BAND",
        "TRANSACTION_TYPE",
    ],
)
def plotting(cat, feature):
    easy_plotting.plot_subcats_by_other_subcats(
        latest_wales_w_upgrades,
        "UPGRADED_" + cat + "_DESCRIPTION",
        feature,
        plotting_colors="inferno",
        x_tick_rotation=45,
        legend_loc="outside",
        fig_save_path=fig_output_path,
    )


# %% [markdown]
# ### Upgrade Network<a id='upgrade_network'></a>
# [[back to top]](#top)
#
# This network shows which upgrades often happen at the same time. Of all the properties with any upgrades, 23% have had an upgrade of lighting and roof.

# %%
upgrades.uprade_connections(first_wales_w_upgrades)

# %% [markdown]
# ## Transitions<a id='transitions'></a>
# [[back to top]](#top)
#
# The transitions show the description of a category before and after an upgrade. Not further pursued at the moment.

# %%
pd.set_option("display.max_rows", 5000)


@interact(cat=cats)
def get_transitions(cat):
    print(
        round(
            latest_wales_w_upgrades["CHANGE_{}_DESCRIPTION".format(cat)].value_counts(
                normalize=True
            ),
            5,
        )
        * 100
    )


# %% [markdown]
# ## Kepler Maps<a id='kepler'></a>
# [[back to top]](#top)
#
# Kepler maps showing upgradability, efficiency and rating difference over time. Not used in that form in the final analysis.
#
#
# ### Geographical and IMD Data
# <a id='supp_data'></a>
# Add geographical data and information about deprivation.

# %%
first_wales_suppl = data_aggregation.get_supplementary_data(
    first_wales_w_upgrades, data_path="S3"
)
first_wales_suppl.head()

# %% [markdown]
# ### Upgradability<a id='upgradability_map'></a>
# [[back to top]](#top)

# %%
kepler_df = data_aggregation.get_aggregated_upgrade_data(first_wales_suppl, "hex_id")

config = kepler.get_config("upgrades.txt", data_path=PROJECT_DIR)
upgrade_map = KeplerGl(height=500, config=config)

upgrade_map.add_data(
    data=kepler_df[["UPGRADABILITY_TOTAL_MEAN", "hex_id"]], name="Total Upgradability"
)

upgrade_map.add_data(
    data=kepler_df[["UPGRADABILITY_ROOF_MEAN", "hex_id"]], name="Roof Upgradability"
)

upgrade_map.add_data(
    data=kepler_df[["UPGRADABILITY_WINDOWS_MEAN", "hex_id"]],
    name="Windows Upgradability",
)

upgrade_map.add_data(
    data=kepler_df[["UPGRADABILITY_MAINHEAT_MEAN", "hex_id"]],
    name="Heating Upgradability",
)

upgrade_map.add_data(
    data=kepler_df[["UPGRADABILITY_LIGHTING_MEAN", "hex_id"]],
    name="Lighting Upgradability",
)

upgrade_map.add_data(
    data=kepler_df[["IMD Decile Hex", "hex_id"]], name="IMD Decile for Hex"
)


upgrade_map

# %%
kepler.save_config(upgrade_map, "upgrades.txt", data_path=PROJECT_DIR)
kepler.save_map(upgrade_map, "Upgrades.html", data_path=PROJECT_DIR)

# %% [markdown]
# ### Upgradability by Local Authority
# <a id='upgradability_map_by_LA'></a>
# [[back to top]](#top)

# %%
kepler_df = data_aggregation.get_aggregated_upgrade_data(
    first_wales_suppl, "LOCAL_AUTHORITY_LABEL"
)

config = kepler.get_config("LA_upgrades.txt", data_path=PROJECT_DIR)
upgrade_map = KeplerGl(height=500, config=config)

upgrade_map.add_data(
    data=kepler_df[
        ["UPGRADABILITY_TOTAL_MEAN", "MOST_FREQUENT_LOCAL_AUTHORITY_LABEL", "hex_id"]
    ],
    name="Total Upgradability",
)

upgrade_map.add_data(
    data=kepler_df[
        ["UPGRADABILITY_ROOF_MEAN", "MOST_FREQUENT_LOCAL_AUTHORITY_LABEL", "hex_id"]
    ],
    name="Roof Upgradability",
)

upgrade_map.add_data(
    data=kepler_df[
        ["UPGRADABILITY_WINDOWS_MEAN", "MOST_FREQUENT_LOCAL_AUTHORITY_LABEL", "hex_id"]
    ],
    name="Windows Upgradability",
)

upgrade_map.add_data(
    data=kepler_df[
        ["UPGRADABILITY_MAINHEAT_MEAN", "MOST_FREQUENT_LOCAL_AUTHORITY_LABEL", "hex_id"]
    ],
    name="Heating Upgradability",
)

upgrade_map.add_data(
    data=kepler_df[
        ["UPGRADABILITY_LIGHTING_MEAN", "MOST_FREQUENT_LOCAL_AUTHORITY_LABEL", "hex_id"]
    ],
    name="Lighting Upgradability",
)

upgrade_map.add_data(
    data=kepler_df[["IMD Decile Hex", "MOST_FREQUENT_LOCAL_AUTHORITY_LABEL", "hex_id"]],
    name="IMD Decile for Hex",
)

upgrade_map

# %%
kepler.save_config(upgrade_map, "LA_upgrades.txt", data_path=PROJECT_DIR)
kepler.save_map(upgrade_map, "LA_Upgrades.html", data_path=PROJECT_DIR)

# %% [markdown]
# ## Energy Efficiency
# <a id='en_eff'></a>
# [[back to top]](#top)

# %%
kepler_df = data_aggregation.get_aggregated_upgrade_data(first_wales_suppl, "hex_id")

config = kepler.get_config("efficiencies.txt", data_path=PROJECT_DIR)
upgrade_map = KeplerGl(height=500, config=config)

upgrade_map.add_data(
    data=kepler_df[["TOTAL_ENERGY_EFF_NUM_MEAN", "hex_id"]],
    name="Total Energy Efficiency",
)

upgrade_map.add_data(
    data=kepler_df[["ROOF_ENERGY_EFF_NUM_MEAN", "hex_id"]],
    name="Roof Energy Efficiency",
)

upgrade_map.add_data(
    data=kepler_df[["WINDOWS_ENERGY_EFF_NUM_MEAN", "hex_id"]],
    name="Windows Energy Efficiency",
)

upgrade_map.add_data(
    data=kepler_df[["MAINHEAT_ENERGY_EFF_NUM_MEAN", "hex_id"]],
    name="Heating Energy Efficiency",
)

upgrade_map.add_data(
    data=kepler_df[["LIGHTING_ENERGY_EFF_NUM_MEAN", "hex_id"]],
    name="Lighting Energy Efficiency",
)

upgrade_map.add_data(
    data=kepler_df[["IMD Decile Hex", "hex_id"]], name="IMD Decile for Hex"
)

upgrade_map

# %%
kepler.save_config(upgrade_map, "efficiencies.txt", data_path=PROJECT_DIR)
kepler.save_map(upgrade_map, "Efficiencies.html", data_path=PROJECT_DIR)

# %% [markdown]
# ## Rating Diff<a id='rating_diff'></a>
# [[back to top]](#top)

# %%
kepler_df = data_aggregation.get_aggregated_upgrade_data(first_wales_suppl, "hex_id")

config = kepler.get_config("diffs.txt", data_path=PROJECT_DIR)
upgrade_map = KeplerGl(height=500, config=config)

upgrade_map.add_data(
    data=kepler_df[["TOTAL_EFF_DIFF_MEAN", "hex_id"]], name="Total Upgrades"
)

upgrade_map.add_data(
    data=kepler_df[["ROOF_EFF_DIFF_MEAN", "hex_id"]], name="Roof Upgrades"
)

upgrade_map.add_data(
    data=kepler_df[["WINDOWS_EFF_DIFF_MEAN", "hex_id"]], name="Windows Upgrades"
)


upgrade_map.add_data(
    data=kepler_df[["MAINHEAT_EFF_DIFF_MEAN", "hex_id"]], name="Heating Upgrades"
)

upgrade_map.add_data(
    data=kepler_df[["LIGHTING_EFF_DIFF_MEAN", "hex_id"]], name="Lighting Upgrades"
)

upgrade_map.add_data(
    data=kepler_df[["IMD Decile Hex", "hex_id"]], name="IMD Decile for Hex"
)
upgrade_map

# %%
kepler.save_config(upgrade_map, "diffs.txt", data_path=PROJECT_DIR)
kepler.save_map(upgrade_map, "Differences.html", data_path=PROJECT_DIR)

# %%
